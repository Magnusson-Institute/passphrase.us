
    Base32mi (v03)

    base64 has many issues with ambiguity in (human) transcription. in
    response there have been a few attempts at defining a subset (aka
    "base32"); none of these have quite taken off.

    base32mi is our attempt at this. As it turns out, we have iterated
    the design several times, so until it's finalized, we suggest you
    reference it by version (current is base32mi.v03).

    ================
  
    base32 encodes in chunks of 5 bits rather than 6. We strive
    to remove as much ambiguity as possible, as well as a few other
    goals.

    Current (v03) set is (32 characters):

       0123456789abcdefyhEjkLmnHpFrRTUW
       12345678901234567890123456789012

    Part of the design intent is to encode some "error correction";
    thus the following substitutions (from "synonym" to "symbol")
    can be performed by a site that accepts base32mi.

     Value    Symbol    Synonyms         
       0        0       O o Q D
       1        1       l I i J
       2        2       Z z
       3        3        
       4        4       A
       5        5       S s
       6        6       G
       7        7       t
       8        8       B
       9        9       g q
       10       a        
       11       b        
       12       c       C
       13       d        
       14       e        
       15       f        
       16       y       Y
       17       h       n 
       18       E        
       19       j        
       20       K       k x X
       21       L        
       22       m       M
       23       N       
       24       H        
       25       P       p
       26       F        
       27       r        
       28       R        
       29       T        
       30       U       u v V
       31       W       w
                        

    The following JS snippet does this substitution:

    str.replace(/OoQD/g,'0').replace(/lIiJ/g,'1').replace(/Zz/g,'2').replace(/A/g,'4').replace(/Ss/g,'5').replace(/G/g,'6').replace(/t/g,'7').replace(/B/g,'8').replace(/gq/g,'9').replace(/C/g,'c').replace(/Y/g,'y').replace(/kxX/g,'K').replace(/M/g,'m').replace(/h/g,'n').replace(/p/g,'P').replace(/uvV/g,'U').replace(/w/g,'w');
   
    (TODO: a JS snippet that will determine, with high probability, if
    a password is encoded in base32mi or not)

    One drawback of the above design is it does NOT preserve ASCII lexical order.

    base32mi has 10 numerals, 11 upper case letters, and 11 lowercase.

    Symbols are excluded for ease of use. In conjunction with a password generator,
    we suggest additional wording such as "if a website requires at least on
    symbol, then just add one at the end such as '#', '$', or '%'.

    This maximum spread of the 32 characters will maximize (*) the
    probability that a random string will contain at least one of
    each, in the situations (such as this implementation) where we
    want to maximize acceptability by typical web password systems:

       0123456789
       abcdefhjmry
       EFHKLNPRTUW

       12345678901
    
    Current NIST (as of 2022) recommendations are 8 characters if
    chosen by a user, and 6 if assigned by a system: we therefore
    recommend 8 base32mi characters generated by computer.


    (*) Restricting to "at least one of each type" leads to:

    32**8 - (22**8 + 21**8 + 21**8) + (11**8 + 10**8 + 10**8)

    which equal 969,404,394,399 which vs 32**8 means we "lose" 12% of possible
    passwords; in entropy that means we go from 40.0 bits to 39.8 bits, so the
    loss is neglible. A greater skew in upper/lower would have some impact but
    not a lot, for example a 10/16/6 design would lead to 39.6 bits. Similarly,
    the entropy loss of a constraint like this even on shorter passwords is
    surprisingly small, for example applying the same limitation to a 6-character
    passwords moves the entropy from 30.0 to 29.6. 

    From our analysis of keyboards etc for the base64mi design,
    we know that the "?" symbol is the least problematic, and it's
    also one that is common at the end of ordinary sentences. Ergo
    we would recommend simply adding "?" at the end for any situation
    where the system requires a symbol.

